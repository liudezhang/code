let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello3let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello2/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})hello1你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);/* 
    删除目录
*/let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello3let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello2/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})hello1你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello3hello2/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);/* 
    删除目录
*/

let fs = require('fs');

fs.rmdir('./测试', function (err) {
    err ? console.log('删除失败') : console.log('删除成功')
})hello3let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello3let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello2/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})hello1你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);/* 
    删除目录
*/let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

module.exports = {
    fsRead,
    fsWrite
};/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello2let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello3/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello1今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    数组二进制的存储
    1、数组不能进行二进制数据的操作
    2、js数组不像Java、Python的语言效率高
    3、buffer内存空间开辟出固定大小的内存
*/


// 将字符串 转成buffer对象
let str = 'HelloWorld'

let buf = Buffer.from(str);

console.log(buf);

// 输出buffer

console.log(buf.toString())


// 开辟一个空的buffer（缓冲区）
// 安全 效率低  清空数据
let buf1 = Buffer.alloc(20);
buf1[0] = 255
console.log(buf1)


// 不安全 效率高 直接在内存中给你一块地址（不清空数据）
let buf2 = Buffer.allocUnsafe(20);
console.log(buf2);hello3今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello2/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello1/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            let content = await fsRead('./' + filesName)
            await fsWrite(path, content, flag = 'a')
            console.log(filesName);
        })
    }
})hello3hello2<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})let fs = require('fs');
// 删除
fs.unlink(('./cf.css'), function () {
    console.log('删除成功')
});今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
今晚吃炒饭
今晚和奶茶
今晚不洗澡
hello3let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>刘德樟</h1>
    <h1>毕家豪</h1>
  </body>
</html>
hello2/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})hello1你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);hello3hello2/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();let fs = require('fs');

// 读文件封装
/* 
    path：文件地址
    flag：文件操作方式
    encoding：文件字符编码
*/
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}
// 写文件封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content, flag = 'a', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: flag,
            encoding: encoding
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

// 暴露接口（导出）解构的方法
module.exports = {
    fsRead,
    fsWrite
};/* 
    文件打开
*/

// 导入文件模块
let fs = require('fs');

/* 
    node 读写文件也有同步和异步的接口
*/

// 同步方式
/* 
    fs.openSync(path[, flags, mode])
*/
// 打开文件
let open = fs.openSync('./hello1.txt', 'r')
// console.log(open)
// 读取文件
let buf = Buffer.alloc(20)
let read = fs.readFileSync(open, {
    flag: 'r',
    encoding: 'utf-8'
});
// console.log(read);你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
hello1/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})/* 
    文件读取
*/

// 异步读取文件
/* 
    第一个参数：文件的地址
    第二个参数：可选对象
        参数一：文件的打开方式
        参数二：文件的字符编码
    第三个参数：回调函数
*/
fs.readFile('./hello1.txt', {
    flag: 'r',
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
});

// console.log(1);
fs.readFile('./h.html', {
    encoding: 'utf8'
}, function (err, data) {
    // err ? console.log(err) : console.log(data);
    // console.log(3);
});
// console.log(2)


// 异步读取封装
function fsRead(path, flag = 'r', encoding = 'utf8') {
    return new Promise(function (resolve, reject) {
        fs.readFile(path, {
            flag: flag,
            encoding: encoding
        }, function (err, data) {
            err ? reject(err) : resolve(data);
        })
    })
}

let w = fsRead('./hello3.txt', 'r');
w.then(function (res) {
    // console.log(res);
})

async function ReadList() {
    let f1 = await fsRead('./hello1.txt');
    let f2 = await fsRead(f1 + '.txt');
    let f3 = await fsRead(f2 + '.txt');
    console.log(f1, f1.length);
    console.log(f2, f2.length);
    console.log(f3, f3.length);
}

ReadList();你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
你叫什么?
/* 
    目录的读取
*/

let fs = require('fs');
const {
    fsRead,
    fsWrite
} = require('./fs');


const path = 'all.txt'
fs.readdir('../02-fs/', function (err, files) {
    if (err) {
        console.log(err)
    } else {
        console.log(files)
        files.forEach(async (filesName, index) => {
            // 读取每个文件的内容
            let content = await fsRead('./' + filesName)
            // 把每个文件的内容写入到指定文件中
            await fsWrite(path, content, flag = 'a+')
            // 输出文件名
            console.log(filesName);
        })
    }
})/* 
    文件的写入
*/

let fs = require('fs');
// 异步写入
fs.writeFile('./test.txt', '你叫什么?\n', {
    flag: 'a',
    encoding: 'utf8'
}, function (err) {
    if (err) {
        console.log('写入出错')
    } else {
        console.log('写入成功')
    }
})

// 封装
/* 
    path:文件地址
    content：要写入的内容
*/
function fsWrite(path, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(path, content, {
            flag: 'a',
            encoding: 'utf8'
        }, function (err) {
            if (err) {
                reject(err)
            } else {
                resolve(err)
            }
        })
    })
}

async function writeList() {
    await fsWrite('cf.txt', '今晚吃炒饭\n');
    await fsWrite('cf.txt', '今晚和奶茶\n');
    await fsWrite('cf.txt', '今晚不洗澡\n');
    // await fsWrite('cf.py', '今晚吃炒饭\n');
    // await fsWrite('cf.css', '今晚和奶茶\n');
    // await fsWrite('cf.less', '今晚不洗澡\n');
}

writeList();hello2